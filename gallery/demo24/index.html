<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="../../static/style.css">
<title>demo24 — I❤LA</title>
<body>
  <header>
    <link href="../../static/prism.css" rel="stylesheet" />
    <h1> demo24 </h1>
  </header>
  <script src="../../static/prism.js"></script>
  <div class="page">
    
  

  
    <div class="gallery_post">

    <p>This page shows demo24 implementation.</p>


    
     It comes from  <a href="https://pressureless.github.io/resource/Classic_papers/A%20Morphable%20Model%20For%20The%20Synthesis%20Of%203D%20Faces/A%20Morphable%20Model%20For%20The%20Synthesis%20Of%203D%20Faces.pdf"> A Morphable Model For The Synthesis Of 3D Faces </a><br><br>
    
    
    
    Here is the description: <br>
      <img src=../../static/gallery_res/demo24/demo24.png alt="placeholder" width="700" style='object-fit: scale-down;'><br>
    

    
      <br> Here is the LA input: <br>
      <div class="code_block"><pre ><code class="language-cpsp">E = 1/`σ_N`^2`E_I` + sum_(j for j&gt;1) α_j²/`σ_S`_j^2  + sum_(j for j&gt;1) β_j²/`σ_T`_j^2   + sum_j (ρ_j-`ρ_bar`_j)²/`σ_ρ`_j^2 

where

`σ_N`: ℝ 
`E_I`: ℝ
α_i : ℝ
β_i : ℝ
`σ_S`_i: ℝ 
`σ_T`_i: ℝ 
ρ_i: ℝ 
`ρ_bar`_i: ℝ 
`σ_ρ`_i: ℝ 
ā_i: ℝ </code></pre></div>
    

    
      <br> Here is the Eigen output: <br>
      <div class="code_block"><pre ><code class="language-cpp">/*

E = 1/`σ_N`^2`E_I` + sum_(j for j&gt;1) α_j²/`σ_S`_j^2  + sum_(j for j&gt;1) β_j²/`σ_T`_j^2   + sum_j (ρ_j-`ρ_bar`_j)²/`σ_ρ`_j^2 

where

`σ_N`: ℝ 
`E_I`: ℝ
α_i : ℝ
β_i : ℝ
`σ_S`_i: ℝ 
`σ_T`_i: ℝ 
ρ_i: ℝ 
`ρ_bar`_i: ℝ 
`σ_ρ`_i: ℝ 
ā_i: ℝ 
*/
#include &lt;Eigen/Core&gt;
#include &lt;Eigen/Dense&gt;
#include &lt;Eigen/Sparse&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;

/**
 * demo24
 *
 * @param σ_N  ℝ
 * @param E_I  ℝ
 * @param α  ℝ
 * @param β  ℝ
 * @param σ_S  ℝ
 * @param σ_T  ℝ
 * @param ρ  ℝ
 * @param ρ_bar  ℝ
 * @param σ_ρ  ℝ
 * @param ā  ℝ
 * @return E
 */
double demo24(
    const double &amp; σ_N,
    const double &amp; E_I,
    const std::vector&lt;double&gt; &amp; α,
    const std::vector&lt;double&gt; &amp; β,
    const std::vector&lt;double&gt; &amp; σ_S,
    const std::vector&lt;double&gt; &amp; σ_T,
    const std::vector&lt;double&gt; &amp; ρ,
    const std::vector&lt;double&gt; &amp; ρ_bar,
    const std::vector&lt;double&gt; &amp; σ_ρ,
    const std::vector&lt;double&gt; &amp; ā)
{
    const long _dim_0 = α.size();
    assert( α.size() == _dim_0 );
    assert( β.size() == _dim_0 );
    assert( σ_S.size() == _dim_0 );
    assert( σ_T.size() == _dim_0 );
    assert( ρ.size() == _dim_0 );
    assert( ρ_bar.size() == _dim_0 );
    assert( σ_ρ.size() == _dim_0 );
    assert( ā.size() == _dim_0 );

    double _sum_0 = 0;
    for(int j=1; j&lt;=α.size(); j++){
        if(j &gt; 1){
            _sum_0 += pow(α.at(j-1), 2) / pow(σ_S.at(j-1), 2);
        }
    }
    double _sum_1 = 0;
    for(int j=1; j&lt;=β.size(); j++){
        if(j &gt; 1){
            _sum_1 += pow(β.at(j-1), 2) / pow(σ_T.at(j-1), 2);
        }
    }
    double _sum_2 = 0;
    for(int j=1; j&lt;=ρ.size(); j++){
        _sum_2 += pow((ρ.at(j-1) - ρ_bar.at(j-1)), 2) / pow(σ_ρ.at(j-1), 2);
    }
    double E = 1 / pow(σ_N, 2) * E_I + _sum_0 + _sum_1 + _sum_2;

    return E;
}


void generateRandomData(double &amp; σ_N,
    double &amp; E_I,
    std::vector&lt;double&gt; &amp; α,
    std::vector&lt;double&gt; &amp; β,
    std::vector&lt;double&gt; &amp; σ_S,
    std::vector&lt;double&gt; &amp; σ_T,
    std::vector&lt;double&gt; &amp; ρ,
    std::vector&lt;double&gt; &amp; ρ_bar,
    std::vector&lt;double&gt; &amp; σ_ρ,
    std::vector&lt;double&gt; &amp; ā)
{
    σ_N = rand() % 10;
    E_I = rand() % 10;
    const int _dim_0 = rand()%10;
    α.resize(_dim_0);
    for(int i=0; i&lt;_dim_0; i++){
        α[i] = rand() % 10;
    }
    β.resize(_dim_0);
    for(int i=0; i&lt;_dim_0; i++){
        β[i] = rand() % 10;
    }
    σ_S.resize(_dim_0);
    for(int i=0; i&lt;_dim_0; i++){
        σ_S[i] = rand() % 10;
    }
    σ_T.resize(_dim_0);
    for(int i=0; i&lt;_dim_0; i++){
        σ_T[i] = rand() % 10;
    }
    ρ.resize(_dim_0);
    for(int i=0; i&lt;_dim_0; i++){
        ρ[i] = rand() % 10;
    }
    ρ_bar.resize(_dim_0);
    for(int i=0; i&lt;_dim_0; i++){
        ρ_bar[i] = rand() % 10;
    }
    σ_ρ.resize(_dim_0);
    for(int i=0; i&lt;_dim_0; i++){
        σ_ρ[i] = rand() % 10;
    }
    ā.resize(_dim_0);
    for(int i=0; i&lt;_dim_0; i++){
        ā[i] = rand() % 10;
    }
}


int main(int argc, char *argv[])
{
    double σ_N;
    double E_I;
    std::vector&lt;double&gt; α;
    std::vector&lt;double&gt; β;
    std::vector&lt;double&gt; σ_S;
    std::vector&lt;double&gt; σ_T;
    std::vector&lt;double&gt; ρ;
    std::vector&lt;double&gt; ρ_bar;
    std::vector&lt;double&gt; σ_ρ;
    std::vector&lt;double&gt; ā;
    generateRandomData(σ_N, E_I, α, β, σ_S, σ_T, ρ, ρ_bar, σ_ρ, ā);
    double func_value = demo24(σ_N, E_I, α, β, σ_S, σ_T, ρ, ρ_bar, σ_ρ, ā);
    std::cout&lt;&lt;&#34;func_value:\n&#34;&lt;&lt;func_value&lt;&lt;std::endl;
    return 0;
}</code></pre></div>
    

    
      <br> Here is the Python output: <br>
      <div class="code_block"><pre ><code class="language-python">&#34;&#34;&#34;

E = 1/`σ_N`^2`E_I` + sum_(j for j&gt;1) α_j²/`σ_S`_j^2  + sum_(j for j&gt;1) β_j²/`σ_T`_j^2   + sum_j (ρ_j-`ρ_bar`_j)²/`σ_ρ`_j^2 

where

`σ_N`: ℝ 
`E_I`: ℝ
α_i : ℝ
β_i : ℝ
`σ_S`_i: ℝ 
`σ_T`_i: ℝ 
ρ_i: ℝ 
`ρ_bar`_i: ℝ 
`σ_ρ`_i: ℝ 
ā_i: ℝ 
&#34;&#34;&#34;
import numpy as np
import scipy
import scipy.linalg
from scipy import sparse
from scipy.integrate import quad
from scipy.optimize import minimize


def demo24(σ_N, E_I, α, β, σ_S, σ_T, ρ, ρ_bar, σ_ρ, ā):
    &#34;&#34;&#34;
    :param :σ_N : ℝ
    :param :E_I : ℝ
    :param :α : ℝ
    :param :β : ℝ
    :param :σ_S : ℝ
    :param :σ_T : ℝ
    :param :ρ : ℝ
    :param :ρ_bar : ℝ
    :param :σ_ρ : ℝ
    :param :ā : ℝ
    &#34;&#34;&#34;
    α = np.asarray(α)
    β = np.asarray(β)
    σ_S = np.asarray(σ_S)
    σ_T = np.asarray(σ_T)
    ρ = np.asarray(ρ)
    ρ_bar = np.asarray(ρ_bar)
    σ_ρ = np.asarray(σ_ρ)
    ā = np.asarray(ā)

    _dim_0 = α.shape[0]
    assert np.ndim(σ_N) == 0
    assert np.ndim(E_I) == 0
    assert α.shape == (_dim_0,)
    assert β.shape == (_dim_0,)
    assert σ_S.shape == (_dim_0,)
    assert σ_T.shape == (_dim_0,)
    assert ρ.shape == (_dim_0,)
    assert ρ_bar.shape == (_dim_0,)
    assert σ_ρ.shape == (_dim_0,)
    assert ā.shape == (_dim_0,)

    _sum_0 = 0
    for j in range(1, len(α)+1):
        if(j &gt; 1):
            _sum_0 += np.power(α[j-1], 2) / np.power(σ_S[j-1], 2)
    _sum_1 = 0
    for j in range(1, len(β)+1):
        if(j &gt; 1):
            _sum_1 += np.power(β[j-1], 2) / np.power(σ_T[j-1], 2)
    _sum_2 = 0
    for j in range(1, len(ρ)+1):
        _sum_2 += np.power((ρ[j-1] - ρ_bar[j-1]), 2) / np.power(σ_ρ[j-1], 2)
    E = 1 / np.power(σ_N, 2) * E_I + _sum_0 + _sum_1 + _sum_2

    return E


def generateRandomData():
    σ_N = np.random.randn()
    E_I = np.random.randn()
    _dim_0 = np.random.randint(10)
    α = np.random.randn(_dim_0)
    β = np.random.randn(_dim_0)
    σ_S = np.random.randn(_dim_0)
    σ_T = np.random.randn(_dim_0)
    ρ = np.random.randn(_dim_0)
    ρ_bar = np.random.randn(_dim_0)
    σ_ρ = np.random.randn(_dim_0)
    ā = np.random.randn(_dim_0)
    return σ_N, E_I, α, β, σ_S, σ_T, ρ, ρ_bar, σ_ρ, ā


if __name__ == &#39;__main__&#39;:
    σ_N, E_I, α, β, σ_S, σ_T, ρ, ρ_bar, σ_ρ, ā = generateRandomData()
    print(&#34;σ_N:&#34;, σ_N)
    print(&#34;E_I:&#34;, E_I)
    print(&#34;α:&#34;, α)
    print(&#34;β:&#34;, β)
    print(&#34;σ_S:&#34;, σ_S)
    print(&#34;σ_T:&#34;, σ_T)
    print(&#34;ρ:&#34;, ρ)
    print(&#34;ρ_bar:&#34;, ρ_bar)
    print(&#34;σ_ρ:&#34;, σ_ρ)
    print(&#34;ā:&#34;, ā)
    func_value = demo24(σ_N, E_I, α, β, σ_S, σ_T, ρ, ρ_bar, σ_ρ, ā)
    print(&#34;func_value: &#34;, func_value)</code></pre></div>
    

    
      <br> Here is the Tex output: <br>
      <div class="code_block"><pre ><code class="language-tex">\documentclass[12pt]{article}
\usepackage{mathdots}
\usepackage[bb=boondox]{mathalfa}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{ctex}
\setmainfont{Linux Libertine O}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{document}
\[
\textit{E} = \frac{1}{\textit{σ\_N}^{2}}\textit{E\_I} + \sum_{\textit{j} &gt; 1} \frac{\textit{α}_{ \textit{j} }^{2}}{\textit{σ\_S}_{ \textit{j} }^{2}} + \sum_{\textit{j} &gt; 1} \frac{\textit{β}_{ \textit{j} }^{2}}{\textit{σ\_T}_{ \textit{j} }^{2}} + \sum_\textit{j} \frac{(\textit{ρ}_{ \textit{j} } - \textit{ρ\_bar}_{ \textit{j} })^{2}}{\textit{σ\_ρ}_{ \textit{j} }^{2}}
\]

where
\begin{itemize}
\item $\textit{σ\_N} \in \mathbb{{R}}$
\item $\textit{E\_I} \in \mathbb{{R}}$
\item $\textit{α}_{\textit{i}} \in \mathbb{{R}}$
\item $\textit{β}_{\textit{i}} \in \mathbb{{R}}$
\item $\textit{σ\_S}_{\textit{i}} \in \mathbb{{R}}$
\item $\textit{σ\_T}_{\textit{i}} \in \mathbb{{R}}$
\item $\textit{ρ}_{\textit{i}} \in \mathbb{{R}}$
\item $\textit{ρ\_bar}_{\textit{i}} \in \mathbb{{R}}$
\item $\textit{σ\_ρ}_{\textit{i}} \in \mathbb{{R}}$
\item $\textit{ā}_{\textit{i}} \in \mathbb{{R}}$
\end{itemize}


\end{document}</code></pre></div>
    

    
      <br> Below is the pdf: <br>
      <img src=../../static/gallery_res/demo24/demo24.pdf alt="placeholder" width="700" style='object-fit: scale-down;'><br>
    
    </div>
  


 



  </div>
</body>
